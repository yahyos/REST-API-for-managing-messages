# REST API service for managing messages

## Introduction
This is an application which manages messages and provides their details,  specifically whether or not a message is a palindrome. 
The application follows RESTful design and supports the following operations:
- Create, retrieve, update, and delete a message
- List messages

## Technologies used
This REST API service was built mainly using the following technologies:
- Spring Boot (Java)
- Maven
- MySQL

And the service is currently deployed to AWS Elastic Beanstalk

## Architecture
This Web application was designed with the following three layers stack:

                
Web Layer: Acts as an entry point and uppermost layer of the application. It is responsible of processing user’s input and returning the correct response back to the user. It also handle the exceptions thrown by the other layers.
                    
Service Layer: Resides below the web layer. It's the layer containing most of the business logic. 

Repository layer: The lowest layer of a web application and is responsible of communicating with the database.
                                 
                    Web Layer: MessageController (Controller class)
                    Service Layer: MessageService (Service class)
                    Repository Layer: MessageRepository (Repository class)
                    
                    
MessageController: Defines REST endpoints mappings, accepts user's request, handles exceptions and sends back a response

MessageService: Implement the business logic of the API: Validations, palindrome algorithme, etc.

MessageRepository: Used as a link to the pre-configured database through Hibernate (ORM). 
Note: Locally, an H2 in-memory is used as a data storage solution.

## How to run the API service locally?

##### Prerequisites
- Java 8 (installed and added to path)
- Maven (installed and added to path)

1. Clone this github repo
2. In command line, navigate to root folder (where pom.xml exists) and run `mvn install -DskipTests`
3. run `mvn spring-boot:run`

Now, you can access the application in `localhost:5000/api/messages`

###### Using Docker to run the API
Open a terminal, navigate to root folder (where Dockerfile exits) and run the following commands:
  - `docker build -t qlik/messagingservice .`  
  - `docker run -p 5000:5000 qlik/messagingservice`
  
Now, you can access the application in `<docker_machine_ip_address>:5000/api/messages` .

For more information about how to setup docker environment, please visit this  [official documentation page](https://docs.docker.com/get-started/)


#### Note
The application uses an H2 in-memory database by default. if you want to run your app against a MySQL db, please add the following code to the application.properties file in the following path `src\main\resources\application.properties` :
```
spring.datasource.url=jdbc:mysql://localhost:<your_db_port>/<your_db_name>
spring.datasource.username= <username>
spring.datasource.password= <password>
spring.jpa.hibernate.ddl-auto = create   //change it to "none" after first run

```

N.B: 4 messages are Boostrapped and are created automatically in the database.
For reference, take a look at `src\main\java\com\qlik\messagingservice\LoadDatabase.java`

### Running tests locally
I followed TDD during this api development, so a lot of API integration and unit tests were created.
To run these tests locally, please navigate to root folder and run `mvn test`

## Accessing the production app
I deployed this API messages service to AWS Elastic Beanstalk and attached it to a MySQL database using Amazon RDS.
The production API is accessible through this link:
`http://qlikmessagingservice-env.uwwzpeje2c.us-east-2.elasticbeanstalk.com/api/messages`

# API Documentation

### Resource documentation
#### Message type
Message represents the properties of a unique message within the system.

### JSON representation
Here is a JSON representation of a `Message`.

```
{
  "id": 7,
  "content": "level",
  "dateCreated": "2019-02-12T18:05:28.997",
  "dateUpdated" : "2019-02-12T19:06:30.650",
  "palindrome" : true
}
```

### Properties

| Property | Type | Description | Constraints        |
|:---------|:-----|:------------|:-------------------|
| **id**   | long | A unique identifier for the author. | Autogenerated and unique |
| **content** | String | The content of the message. |Content string should not be empty with a length between 1 and 500 characters and containing characters from the following set:`a-z A-Z 0-9 àâäèéêëîïôœùûüÿçÀÂÄ ÈÉÊËÎÏÔŒÙÛÜŸÇ`.|
| **dateCreated** | LocalDateTime  | The message creation date in `yyyy-MM-dd'T'HH:mm:ss` format. | NA|
| **dateUpdated** | LocalDateTime  | The date of the last update of the message in   `yyyy-MM-dd'T'HH:mm:ss` format. | NA |
| **isPalindrome** | boolean | Flag indicating either a message is palindrome or not.| NA |

### Endpoints documentation

### GET
Retrieve an existing message with a unique id

#### Prerequisites

Needs a valid existing message id in the url path

#### HTTP Request

```
GET /api/messages/{id}
```

#### Request body

Do not supply a request body with this method.

#### Example

##### Request

```
GET http://localhost:5000/api/messages/3
```

##### Response
Response status
``` 
200 OK
```

Response body
```
{
    "data": {
        "id": 3,
        "content": "level",
        "dateCreated": "2019-02-12T18:05:29.762",
        "dateUpdated": "2019-02-12T18:10:24.164",
        "palindrome": true
    }
}
```


### GET-LIST

List all available messages

#### HTTP Request

```
 GET /api/messages
```
#### Request parameters

In the request URL, provide the following query parameters with values.

| Parameter | Type | Description | Required |
|:----------|:-----|:------------|:---------|
|isPalindrome| boolean | filter messages by palindrome | false

#### Request body

Do not supply a request body with this method.

#### Example

##### Request

```
GET http://localhost:5000/api/messages
```

##### Response
Response status
``` 
200 OK
```

Response body
```
{
    "data": [
        {
            "id": 1,
            "content": "madam",
            "dateCreated": "2019-02-12T18:05:28.997",
            "dateUpdated": "2019-02-12T18:10:32.233",
            "palindrome": true
        },
        {
            "id": 2,
            "content": "normal",
            "dateCreated": "2019-02-12T18:05:29.183",
            "dateUpdated": "2019-02-12T18:05:29.183",
            "palindrome": false
        },
        {
            "id": 3,
            "content": "level",
            "dateCreated": "2019-02-12T18:05:29.762",
            "dateUpdated": "2019-02-12T18:10:24.164",
            "palindrome": true
        }
    ]
}
```

### POST

Create a new message

#### HTTP Request

```
POST /api/messages
```

#### Request headers

| Name | Value |
|:-------------|:------------|
| Content-Type | application/json

#### Request body

The body of the POST request should be a valid json containing only one key called `'content'`.
The value of this key needs to satisfy the following criterias:
  - String type
  - Not empty
  - Length between 1 and 500
  - Contains characters from the following set: `a-zA-Z0-9 àâäèéêëîïôœùûüÿçÀÂÄ ÈÉÊËÎÏÔŒÙÛÜŸÇ`
  
#### Example

##### Request

```
POST http://localhost:5000/api/messages
```
Request body:
```
{
    "content": "normal"
}
```

##### Response
Response status
``` 
200 OK
```

Response body
```
{
    "id": 4,
    "content": "normal",
    "dateCreated": "2019-02-12T20:32:50.128",
    "dateUpdated": "2019-02-12T20:32:50.128",
    "palindrome": false
}
```


### PUT

Update an existing message

#### Prerequisites

Needs a valid existing message id in the url path

#### HTTP Request

```
PUT /api/messages/{id}
```

#### Request headers

| Name | Value |
|:-------------|:------------|
| Content-Type | application/json

#### Request body

The body of the PUT request should be a valid json containing only one key called `'content'`.
The value of this key needs to satisfy the following criterias:
  - String type
  - Not empty
  - Length between 1 and 500
  - Contains characters from the following set: `a-zA-Z0-9 àâäèéêëîïôœùûüÿçÀÂÄ ÈÉÊËÎÏÔŒÙÛÜŸÇ`
  
#### Example

##### Request

```
PUT http://localhost:5000/api/messages/3
```
Request body:
```
{
    "content": "not palindrome"
}
```

##### Response
Response status
``` 
200 OK
```

Response body
```
{
        "id": 3,
        "content": "not palindrome",
        "dateCreated": "2019-02-12T18:05:29.762",
        "dateUpdated": "2019-02-13T21:10:22.847",
        "palindrome": false
}
```

### DELETE
Delete an existing message with a unique id

#### Prerequisites

Needs a valid existing message id in the url path

#### HTTP Request

```
DELETE /api/messages/{id}
```

#### Request body

Do not supply a request body with this method.

#### Example

##### Request

```
DELETE http://localhost:5000/api/messages/3
```

##### Response

Response status
```
204 No Content
```

### Testing the API

Follow the documentation above for the desired endpoint and use either Postman or curl to make the API requests:
- Locally, to: `http://localhost:5000/api/messages`
- In production, to: `http://qlikmessagingservice-env.uwwzpeje2c.us-east-2.elasticbeanstalk.com/api/messages`


# Possible extensions for this project
This project was not intended to reflect a real production app of the industry scale, so a lot of possible extensions can take place:
- Extend the model to real life scenario with three Entities instead of one:
Message, User, GroupChat and implement an authentication layer to protect resources 
(Possible technologies: Spring Security, OAuth protocol, OpenId)
- Implement Cashing for quick responses (Possible technologies: Spring Boot cashing)
- If the model is more than one entity, it's better to make this REST API more mature by implementing HATEOAS links to make it an explorable API (Big debate about if we can even consider an API REST without following HATEOAS ☺️)
- Implement sorting and pagination for the GET-List endpoint
- Use Kubernetes for orchestration
 


